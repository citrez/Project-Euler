# The sequence of triangle numbers is generated by adding the natural numbers. 
# So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

# Let us list the factors of the first seven triangle numbers:
#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.

# What is the value of the first triangle number to have over five hundred divisors?

# triangle numbers are the sum of the first n numbers
# there is a well know formula for this

from collections import defaultdict

def sum_to_n(n):
    return int(n* ( (n+1)/2 ) )
# print(sum_to_n(4))

def find_divisors(n):
    return [div for div in range(1,int((n+2)/2) ) if n%div == 0]


from itertools import chain, combinations

def powerset(iterable):
    "powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))

prime_factor_chache = defaultdict(list)

# implement this with caching
def prime_factorise(numb):
    "Prime factorisation using reccursion and caching"

    #still a bit shocked this actually works
    if numb == 1:
        return([])
    if prime_factor_chache[numb]!= []:
        return(prime_factor_chache[numb])
    prime_factors = []
    for i in range(2,numb+1):
        if numb%i == 0:
            prime_factors = [i] + prime_factorise( int(numb/i) ) 
            prime_factor_chache[numb] = prime_factors
            return(prime_factors)

tri_numbs = [sum_to_n(n) for n in range(1,13510)]
print(tri_numbs[0:10])

factorised = dict([ (t,prime_factorise(t)) for t in tri_numbs])
# print(factorised)

power_set = [(f,len(list(set(powerset(factorised[f]) )) )) for f in factorised.keys()]

the_max= max([ i[1] for i in power_set])
for  i in power_set:
    if i[1]> 500:
        print(i)

print(prime_factorise(76576500))
print(set(list(powerset([2, 2, 3, 3, 5, 5, 5, 7, 11, 13, 17]))))



# print( max([ len(list(i) ) for i in power_set ] ) ) 



# for i in range(1,10):
#     tri_num=sum_to_n(i)
#     print(tri_num)
#     prime_factorise(tri_num)

# print((prime_factor_chache))
# print(len(prime_factor_chache))





# we watch to do some sort of caching, 
# because we dont want to recalculate
# prime factorisation each time
# divisors_dict = defaultdict(int)

# for i in range(1,1000):
#     triangle_num = sum_to_n(i)
#     if divisors_dict[i]!= 0:
#         divisors = divisors_dict[i]

#     else:
#         pf =prime_factorise(i)
#         pf.remove(1)
#         pf = [divisors_dict[i] for i in pf if divisors_dict[i]!=0]
#         for i in pf:
#             if divisors_dict[i]!=0:
#                 divisors_dict[i]
#             else:
#                 i
#         print(pf)
#         divisors = set( powerset( pf ) )
#         divisors_dict[i] = divisors
    
#     if len(divisors)>100:
#         print('yay')
#         print(i)
#         break

# print((divisors_dict))
 #   print(prime_factorise(triangle_num)
#     all_divisors = find_divisors(triangle_num)
#     if divisors_dict[]
#     print(len(all_divisors))
    # if len(all_divisors)>500:
        # print(f"Harrah, triangle number: {triangle_num} has {len(all_divisors)} divisors")